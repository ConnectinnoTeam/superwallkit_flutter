// Autogenerated from Pigeon (v25.2.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")


import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): FlutterError {
  return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()
private fun deepEqualsHost(a: Any?, b: Any?): Boolean {
  if (a is ByteArray && b is ByteArray) {
      return a.contentEquals(b)
  }
  if (a is IntArray && b is IntArray) {
      return a.contentEquals(b)
  }
  if (a is LongArray && b is LongArray) {
      return a.contentEquals(b)
  }
  if (a is DoubleArray && b is DoubleArray) {
      return a.contentEquals(b)
  }
  if (a is Array<*> && b is Array<*>) {
    return a.size == b.size &&
        a.indices.all{ deepEqualsHost(a[it], b[it]) }
  }
  if (a is Map<*, *> && b is Map<*, *>) {
    return a.size == b.size && a.keys.all {
        (b as Map<Any?, Any?>).containsKey(it) &&
        deepEqualsHost(a[it], b[it])
    }
  }
  return a == b;
}
    

enum class PNetworkEnvironment(val raw: Int) {
  /** Default: Uses the standard latest environment. */
  RELEASE(0),
  /**
   * **WARNING**: Uses a release candidate environment. This is not meant
   * for a production environment.
   */
  RELEASE_CANDIDATE(1),
  /**
   * **WARNING**: Uses the nightly build environment. This is not meant for
   * a production environment.
   */
  DEVELOPER(2);

  companion object {
    fun ofRaw(raw: Int): PNetworkEnvironment? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PLogLevel(val raw: Int) {
  DEBUG(0),
  INFO(1),
  WARN(2),
  ERROR(3),
  NONE(4);

  companion object {
    fun ofRaw(raw: Int): PLogLevel? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PTransactionBackgroundView(val raw: Int) {
  SPINNER(0),
  NONE(1);

  companion object {
    fun ofRaw(raw: Int): PTransactionBackgroundView? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PLogScope(val raw: Int) {
  LOCALIZATION_MANAGER(0),
  BOUNCE_BUTTON(1),
  CORE_DATA(2),
  CONFIG_MANAGER(3),
  IDENTITY_MANAGER(4),
  DEBUG_MANAGER(5),
  DEBUG_VIEW_CONTROLLER(6),
  LOCALIZATION_VIEW_CONTROLLER(7),
  GAME_CONTROLLER_MANAGER(8),
  DEVICE(9),
  NETWORK(10),
  PAYWALL_EVENTS(11),
  PRODUCTS_MANAGER(12),
  STORE_KIT_MANAGER(13),
  PLACEMENTS(14),
  RECEIPTS(15),
  SUPERWALL_CORE(16),
  PAYWALL_PRESENTATION(17),
  TRANSACTIONS(18),
  PAYWALL_VIEW_CONTROLLER(19),
  CACHE(20),
  ALL(21);

  companion object {
    fun ofRaw(raw: Int): PLogScope? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PConfigurationStatus(val raw: Int) {
  PENDING(0),
  CONFIGURED(1),
  FAILED(2);

  companion object {
    fun ofRaw(raw: Int): PConfigurationStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PEventType(val raw: Int) {
  FIRST_SEEN(0),
  APP_OPEN(1),
  APP_LAUNCH(2),
  IDENTITY_ALIAS(3),
  APP_INSTALL(4),
  RESTORE_START(5),
  RESTORE_COMPLETE(6),
  RESTORE_FAIL(7),
  SESSION_START(8),
  DEVICE_ATTRIBUTES(9),
  SUBSCRIPTION_STATUS_DID_CHANGE(10),
  APP_CLOSE(11),
  DEEP_LINK(12),
  TRIGGER_FIRE(13),
  PAYWALL_OPEN(14),
  PAYWALL_CLOSE(15),
  PAYWALL_DECLINE(16),
  TRANSACTION_START(17),
  TRANSACTION_FAIL(18),
  TRANSACTION_ABANDON(19),
  TRANSACTION_COMPLETE(20),
  SUBSCRIPTION_START(21),
  FREE_TRIAL_START(22),
  TRANSACTION_RESTORE(23),
  TRANSACTION_TIMEOUT(24),
  USER_ATTRIBUTES(25),
  NON_RECURRING_PRODUCT_PURCHASE(26),
  PAYWALL_RESPONSE_LOAD_START(27),
  PAYWALL_RESPONSE_LOAD_NOT_FOUND(28),
  PAYWALL_RESPONSE_LOAD_FAIL(29),
  PAYWALL_RESPONSE_LOAD_COMPLETE(30),
  PAYWALL_WEBVIEW_LOAD_START(31),
  PAYWALL_WEBVIEW_LOAD_FAIL(32),
  PAYWALL_WEBVIEW_LOAD_COMPLETE(33),
  PAYWALL_WEBVIEW_LOAD_TIMEOUT(34),
  PAYWALL_WEBVIEW_LOAD_FALLBACK(35),
  PAYWALL_PRODUCTS_LOAD_RETRY(36),
  PAYWALL_PRODUCTS_LOAD_START(37),
  PAYWALL_PRODUCTS_LOAD_FAIL(38),
  PAYWALL_PRODUCTS_LOAD_COMPLETE(39),
  PAYWALL_RESOURCE_LOAD_FAIL(40),
  SURVEY_RESPONSE(41),
  PAYWALL_PRESENTATION_REQUEST(42),
  TOUCHES_BEGAN(43),
  SURVEY_CLOSE(44),
  RESET(45),
  CONFIG_REFRESH(46),
  CUSTOM_PLACEMENT(47),
  CONFIG_ATTRIBUTES(48),
  CONFIRM_ALL_ASSIGNMENTS(49),
  CONFIG_FAIL(50),
  AD_SERVICES_TOKEN_REQUEST_START(51),
  AD_SERVICES_TOKEN_REQUEST_FAIL(52),
  AD_SERVICES_TOKEN_REQUEST_COMPLETE(53),
  SHIMMER_VIEW_START(54),
  SHIMMER_VIEW_COMPLETE(55);

  companion object {
    fun ofRaw(raw: Int): PEventType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PSubscriptionStatusType(val raw: Int) {
  ACTIVE(0),
  INACTIVE(1),
  UNKNOWN(2);

  companion object {
    fun ofRaw(raw: Int): PSubscriptionStatusType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PPaywallPresentationRequestStatusType(val raw: Int) {
  PRESENTATION(0),
  NO_PRESENTATION(1),
  TIMEOUT(2);

  companion object {
    fun ofRaw(raw: Int): PPaywallPresentationRequestStatusType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PPaywallPresentationRequestStatusReason(val raw: Int) {
  DEBUGGER_PRESENTED(0),
  PAYWALL_ALREADY_PRESENTED(1),
  HOLDOUT(2),
  NO_AUDIENCE_MATCH(3),
  PLACEMENT_NOT_FOUND(4),
  NO_PAYWALL_VIEW_CONTROLLER(5),
  NO_PRESENTER(6),
  NO_CONFIG(7),
  SUBSCRIPTION_STATUS_TIMEOUT(8);

  companion object {
    fun ofRaw(raw: Int): PPaywallPresentationRequestStatusReason? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PVariantType(val raw: Int) {
  TREATMENT(0),
  HOLDOUT(1);

  companion object {
    fun ofRaw(raw: Int): PVariantType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PSuperwallOptions (
  val paywalls: PPaywallOptions? = null,
  val networkEnvironment: PNetworkEnvironment? = null,
  val isExternalDataCollectionEnabled: Boolean? = null,
  val localeIdentifier: String? = null,
  val isGameControllerEnabled: Boolean? = null,
  val logging: PLogging? = null,
  val passIdentifiersToPlayStore: Boolean? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PSuperwallOptions {
      val paywalls = pigeonVar_list[0] as PPaywallOptions?
      val networkEnvironment = pigeonVar_list[1] as PNetworkEnvironment?
      val isExternalDataCollectionEnabled = pigeonVar_list[2] as Boolean?
      val localeIdentifier = pigeonVar_list[3] as String?
      val isGameControllerEnabled = pigeonVar_list[4] as Boolean?
      val logging = pigeonVar_list[5] as PLogging?
      val passIdentifiersToPlayStore = pigeonVar_list[6] as Boolean?
      return PSuperwallOptions(paywalls, networkEnvironment, isExternalDataCollectionEnabled, localeIdentifier, isGameControllerEnabled, logging, passIdentifiersToPlayStore)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      paywalls,
      networkEnvironment,
      isExternalDataCollectionEnabled,
      localeIdentifier,
      isGameControllerEnabled,
      logging,
      passIdentifiersToPlayStore,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PSuperwallOptions) {
      return false
    }
    if (this === other) {
      return true
    }
    return paywalls == other.paywalls
    && networkEnvironment == other.networkEnvironment
    && isExternalDataCollectionEnabled == other.isExternalDataCollectionEnabled
    && localeIdentifier == other.localeIdentifier
    && isGameControllerEnabled == other.isGameControllerEnabled
    && logging == other.logging
    && passIdentifiersToPlayStore == other.passIdentifiersToPlayStore
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PPaywallInfo (
  val identifier: String? = null,
  val name: String? = null,
  val experimentBridgeId: String? = null,
  val productIds: List<String>? = null,
  val products: List<Map<String, Any>>? = null,
  val url: String? = null,
  val presentedByPlacementWithName: String? = null,
  val presentedByPlacementWithId: String? = null,
  val presentedByPlacementAt: String? = null,
  val presentedBy: String? = null,
  val presentationSourceType: String? = null,
  val responseLoadStartTime: String? = null,
  val responseLoadCompleteTime: String? = null,
  val responseLoadFailTime: String? = null,
  val responseLoadDuration: Double? = null,
  val webViewLoadStartTime: String? = null,
  val webViewLoadCompleteTime: String? = null,
  val webViewLoadFailTime: String? = null,
  val webViewLoadDuration: Double? = null,
  val productsLoadStartTime: String? = null,
  val productsLoadCompleteTime: String? = null,
  val productsLoadFailTime: String? = null,
  val productsLoadDuration: Double? = null,
  val paywalljsVersion: String? = null,
  val isFreeTrialAvailable: Boolean? = null,
  val featureGatingBehavior: Map<String, Any>? = null,
  val closeReason: Map<String, Any>? = null,
  val localNotifications: List<Map<String, Any>>? = null,
  val computedPropertyRequests: List<Map<String, Any>>? = null,
  val surveys: List<Map<String, Any>>? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PPaywallInfo {
      val identifier = pigeonVar_list[0] as String?
      val name = pigeonVar_list[1] as String?
      val experimentBridgeId = pigeonVar_list[2] as String?
      val productIds = pigeonVar_list[3] as List<String>?
      val products = pigeonVar_list[4] as List<Map<String, Any>>?
      val url = pigeonVar_list[5] as String?
      val presentedByPlacementWithName = pigeonVar_list[6] as String?
      val presentedByPlacementWithId = pigeonVar_list[7] as String?
      val presentedByPlacementAt = pigeonVar_list[8] as String?
      val presentedBy = pigeonVar_list[9] as String?
      val presentationSourceType = pigeonVar_list[10] as String?
      val responseLoadStartTime = pigeonVar_list[11] as String?
      val responseLoadCompleteTime = pigeonVar_list[12] as String?
      val responseLoadFailTime = pigeonVar_list[13] as String?
      val responseLoadDuration = pigeonVar_list[14] as Double?
      val webViewLoadStartTime = pigeonVar_list[15] as String?
      val webViewLoadCompleteTime = pigeonVar_list[16] as String?
      val webViewLoadFailTime = pigeonVar_list[17] as String?
      val webViewLoadDuration = pigeonVar_list[18] as Double?
      val productsLoadStartTime = pigeonVar_list[19] as String?
      val productsLoadCompleteTime = pigeonVar_list[20] as String?
      val productsLoadFailTime = pigeonVar_list[21] as String?
      val productsLoadDuration = pigeonVar_list[22] as Double?
      val paywalljsVersion = pigeonVar_list[23] as String?
      val isFreeTrialAvailable = pigeonVar_list[24] as Boolean?
      val featureGatingBehavior = pigeonVar_list[25] as Map<String, Any>?
      val closeReason = pigeonVar_list[26] as Map<String, Any>?
      val localNotifications = pigeonVar_list[27] as List<Map<String, Any>>?
      val computedPropertyRequests = pigeonVar_list[28] as List<Map<String, Any>>?
      val surveys = pigeonVar_list[29] as List<Map<String, Any>>?
      return PPaywallInfo(identifier, name, experimentBridgeId, productIds, products, url, presentedByPlacementWithName, presentedByPlacementWithId, presentedByPlacementAt, presentedBy, presentationSourceType, responseLoadStartTime, responseLoadCompleteTime, responseLoadFailTime, responseLoadDuration, webViewLoadStartTime, webViewLoadCompleteTime, webViewLoadFailTime, webViewLoadDuration, productsLoadStartTime, productsLoadCompleteTime, productsLoadFailTime, productsLoadDuration, paywalljsVersion, isFreeTrialAvailable, featureGatingBehavior, closeReason, localNotifications, computedPropertyRequests, surveys)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      identifier,
      name,
      experimentBridgeId,
      productIds,
      products,
      url,
      presentedByPlacementWithName,
      presentedByPlacementWithId,
      presentedByPlacementAt,
      presentedBy,
      presentationSourceType,
      responseLoadStartTime,
      responseLoadCompleteTime,
      responseLoadFailTime,
      responseLoadDuration,
      webViewLoadStartTime,
      webViewLoadCompleteTime,
      webViewLoadFailTime,
      webViewLoadDuration,
      productsLoadStartTime,
      productsLoadCompleteTime,
      productsLoadFailTime,
      productsLoadDuration,
      paywalljsVersion,
      isFreeTrialAvailable,
      featureGatingBehavior,
      closeReason,
      localNotifications,
      computedPropertyRequests,
      surveys,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PPaywallInfo) {
      return false
    }
    if (this === other) {
      return true
    }
    return identifier == other.identifier
    && name == other.name
    && experimentBridgeId == other.experimentBridgeId
    && deepEqualsHost(productIds, other.productIds)
    && deepEqualsHost(products, other.products)
    && url == other.url
    && presentedByPlacementWithName == other.presentedByPlacementWithName
    && presentedByPlacementWithId == other.presentedByPlacementWithId
    && presentedByPlacementAt == other.presentedByPlacementAt
    && presentedBy == other.presentedBy
    && presentationSourceType == other.presentationSourceType
    && responseLoadStartTime == other.responseLoadStartTime
    && responseLoadCompleteTime == other.responseLoadCompleteTime
    && responseLoadFailTime == other.responseLoadFailTime
    && responseLoadDuration == other.responseLoadDuration
    && webViewLoadStartTime == other.webViewLoadStartTime
    && webViewLoadCompleteTime == other.webViewLoadCompleteTime
    && webViewLoadFailTime == other.webViewLoadFailTime
    && webViewLoadDuration == other.webViewLoadDuration
    && productsLoadStartTime == other.productsLoadStartTime
    && productsLoadCompleteTime == other.productsLoadCompleteTime
    && productsLoadFailTime == other.productsLoadFailTime
    && productsLoadDuration == other.productsLoadDuration
    && paywalljsVersion == other.paywalljsVersion
    && isFreeTrialAvailable == other.isFreeTrialAvailable
    && deepEqualsHost(featureGatingBehavior, other.featureGatingBehavior)
    && deepEqualsHost(closeReason, other.closeReason)
    && deepEqualsHost(localNotifications, other.localNotifications)
    && deepEqualsHost(computedPropertyRequests, other.computedPropertyRequests)
    && deepEqualsHost(surveys, other.surveys)
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PPurchaseResult (
  val success: Boolean? = null,
  val error: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PPurchaseResult {
      val success = pigeonVar_list[0] as Boolean?
      val error = pigeonVar_list[1] as String?
      return PPurchaseResult(success, error)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      success,
      error,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PPurchaseResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return success == other.success
    && error == other.error
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PRestorationResult (
  val restored: Boolean? = null,
  val error: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PRestorationResult {
      val restored = pigeonVar_list[0] as Boolean?
      val error = pigeonVar_list[1] as String?
      return PRestorationResult(restored, error)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      restored,
      error,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PRestorationResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return restored == other.restored
    && error == other.error
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PRestoreFailed (
  /**
   * The title of the alert presented to the user when restoring a transaction
   * fails.
   */
  val title: String? = null,
  /**
   * Defines the message of the alert presented to the user when restoring a
   * transaction fails.
   */
  val message: String? = null,
  /** Defines the title of the close button in the alert presented to the user. */
  val closeButtonTitle: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PRestoreFailed {
      val title = pigeonVar_list[0] as String?
      val message = pigeonVar_list[1] as String?
      val closeButtonTitle = pigeonVar_list[2] as String?
      return PRestoreFailed(title, message, closeButtonTitle)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      title,
      message,
      closeButtonTitle,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PRestoreFailed) {
      return false
    }
    if (this === other) {
      return true
    }
    return title == other.title
    && message == other.message
    && closeButtonTitle == other.closeButtonTitle
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PLogging (
  val level: PLogLevel? = null,
  val scopes: List<PLogScope>? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PLogging {
      val level = pigeonVar_list[0] as PLogLevel?
      val scopes = pigeonVar_list[1] as List<PLogScope>?
      return PLogging(level, scopes)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      level,
      scopes,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PLogging) {
      return false
    }
    if (this === other) {
      return true
    }
    return level == other.level
    && deepEqualsHost(scopes, other.scopes)
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PPaywallOptions (
  val isHapticFeedbackEnabled: Boolean? = null,
  val restoreFailed: PRestoreFailed? = null,
  val shouldShowPurchaseFailureAlert: Boolean? = null,
  val shouldPreload: Boolean? = null,
  val automaticallyDismiss: Boolean? = null,
  val transactionBackgroundView: PTransactionBackgroundView? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PPaywallOptions {
      val isHapticFeedbackEnabled = pigeonVar_list[0] as Boolean?
      val restoreFailed = pigeonVar_list[1] as PRestoreFailed?
      val shouldShowPurchaseFailureAlert = pigeonVar_list[2] as Boolean?
      val shouldPreload = pigeonVar_list[3] as Boolean?
      val automaticallyDismiss = pigeonVar_list[4] as Boolean?
      val transactionBackgroundView = pigeonVar_list[5] as PTransactionBackgroundView?
      return PPaywallOptions(isHapticFeedbackEnabled, restoreFailed, shouldShowPurchaseFailureAlert, shouldPreload, automaticallyDismiss, transactionBackgroundView)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      isHapticFeedbackEnabled,
      restoreFailed,
      shouldShowPurchaseFailureAlert,
      shouldPreload,
      automaticallyDismiss,
      transactionBackgroundView,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PPaywallOptions) {
      return false
    }
    if (this === other) {
      return true
    }
    return isHapticFeedbackEnabled == other.isHapticFeedbackEnabled
    && restoreFailed == other.restoreFailed
    && shouldShowPurchaseFailureAlert == other.shouldShowPurchaseFailureAlert
    && shouldPreload == other.shouldPreload
    && automaticallyDismiss == other.automaticallyDismiss
    && transactionBackgroundView == other.transactionBackgroundView
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PPurchaseControllerHost (
  val bridgeId: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PPurchaseControllerHost {
      val bridgeId = pigeonVar_list[0] as String?
      return PPurchaseControllerHost(bridgeId)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      bridgeId,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PPurchaseControllerHost) {
      return false
    }
    if (this === other) {
      return true
    }
    return bridgeId == other.bridgeId
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PEntitlement (
  val id: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PEntitlement {
      val id = pigeonVar_list[0] as String?
      return PEntitlement(id)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PEntitlement) {
      return false
    }
    if (this === other) {
      return true
    }
    return id == other.id
  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Generated class from Pigeon that represents data sent in messages.
 * This class should not be extended by any user class outside of the generated file.
 */
sealed class PSubscriptionStatus 
/** Generated class from Pigeon that represents data sent in messages. */
data class PActive (
  val entitlements: List<PEntitlement>
) : PSubscriptionStatus()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PActive {
      val entitlements = pigeonVar_list[0] as List<PEntitlement>
      return PActive(entitlements)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      entitlements,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PActive) {
      return false
    }
    if (this === other) {
      return true
    }
    return deepEqualsHost(entitlements, other.entitlements)
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PInactive (
  val _alwaysFalse: Boolean? = null
) : PSubscriptionStatus()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PInactive {
      val _alwaysFalse = pigeonVar_list[0] as Boolean?
      return PInactive(_alwaysFalse)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      _alwaysFalse,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PInactive) {
      return false
    }
    if (this === other) {
      return true
    }
    return _alwaysFalse == other._alwaysFalse
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PUnknown (
  val _alwaysFalse: Boolean? = null
) : PSubscriptionStatus()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PUnknown {
      val _alwaysFalse = pigeonVar_list[0] as Boolean?
      return PUnknown(_alwaysFalse)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      _alwaysFalse,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PUnknown) {
      return false
    }
    if (this === other) {
      return true
    }
    return _alwaysFalse == other._alwaysFalse
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PPaywallInfoPigeon (
  val identifier: String,
  val name: String,
  val experimentBridgeId: String? = null,
  val productIds: List<String>,
  val products: List<Map<String, Any>>,
  val url: String,
  val presentedByEventWithName: String? = null,
  val presentedByEventWithId: String? = null,
  val presentedByEventAt: Double? = null,
  val presentedBy: String? = null,
  val presentationSourceType: String? = null,
  val responseLoadStartTime: Double? = null,
  val responseLoadCompleteTime: Double? = null,
  val responseLoadFailTime: Double? = null,
  val responseLoadDuration: Double? = null,
  val webViewLoadStartTime: Double? = null,
  val webViewLoadCompleteTime: Double? = null,
  val webViewLoadFailTime: Double? = null,
  val webViewLoadDuration: Double? = null,
  val productsLoadStartTime: Double? = null,
  val productsLoadCompleteTime: Double? = null,
  val productsLoadFailTime: Double? = null,
  val productsLoadDuration: Double? = null,
  val paywalljsVersion: String? = null,
  val isFreeTrialAvailable: Boolean? = null,
  val featureGatingBehavior: Map<String, Any>? = null,
  val closeReason: Map<String, Any>? = null,
  val localNotifications: List<Map<String, Any>>? = null,
  val computedPropertyRequests: List<Map<String, Any>>? = null,
  val surveys: List<Map<String, Any>>? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PPaywallInfoPigeon {
      val identifier = pigeonVar_list[0] as String
      val name = pigeonVar_list[1] as String
      val experimentBridgeId = pigeonVar_list[2] as String?
      val productIds = pigeonVar_list[3] as List<String>
      val products = pigeonVar_list[4] as List<Map<String, Any>>
      val url = pigeonVar_list[5] as String
      val presentedByEventWithName = pigeonVar_list[6] as String?
      val presentedByEventWithId = pigeonVar_list[7] as String?
      val presentedByEventAt = pigeonVar_list[8] as Double?
      val presentedBy = pigeonVar_list[9] as String?
      val presentationSourceType = pigeonVar_list[10] as String?
      val responseLoadStartTime = pigeonVar_list[11] as Double?
      val responseLoadCompleteTime = pigeonVar_list[12] as Double?
      val responseLoadFailTime = pigeonVar_list[13] as Double?
      val responseLoadDuration = pigeonVar_list[14] as Double?
      val webViewLoadStartTime = pigeonVar_list[15] as Double?
      val webViewLoadCompleteTime = pigeonVar_list[16] as Double?
      val webViewLoadFailTime = pigeonVar_list[17] as Double?
      val webViewLoadDuration = pigeonVar_list[18] as Double?
      val productsLoadStartTime = pigeonVar_list[19] as Double?
      val productsLoadCompleteTime = pigeonVar_list[20] as Double?
      val productsLoadFailTime = pigeonVar_list[21] as Double?
      val productsLoadDuration = pigeonVar_list[22] as Double?
      val paywalljsVersion = pigeonVar_list[23] as String?
      val isFreeTrialAvailable = pigeonVar_list[24] as Boolean?
      val featureGatingBehavior = pigeonVar_list[25] as Map<String, Any>?
      val closeReason = pigeonVar_list[26] as Map<String, Any>?
      val localNotifications = pigeonVar_list[27] as List<Map<String, Any>>?
      val computedPropertyRequests = pigeonVar_list[28] as List<Map<String, Any>>?
      val surveys = pigeonVar_list[29] as List<Map<String, Any>>?
      return PPaywallInfoPigeon(identifier, name, experimentBridgeId, productIds, products, url, presentedByEventWithName, presentedByEventWithId, presentedByEventAt, presentedBy, presentationSourceType, responseLoadStartTime, responseLoadCompleteTime, responseLoadFailTime, responseLoadDuration, webViewLoadStartTime, webViewLoadCompleteTime, webViewLoadFailTime, webViewLoadDuration, productsLoadStartTime, productsLoadCompleteTime, productsLoadFailTime, productsLoadDuration, paywalljsVersion, isFreeTrialAvailable, featureGatingBehavior, closeReason, localNotifications, computedPropertyRequests, surveys)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      identifier,
      name,
      experimentBridgeId,
      productIds,
      products,
      url,
      presentedByEventWithName,
      presentedByEventWithId,
      presentedByEventAt,
      presentedBy,
      presentationSourceType,
      responseLoadStartTime,
      responseLoadCompleteTime,
      responseLoadFailTime,
      responseLoadDuration,
      webViewLoadStartTime,
      webViewLoadCompleteTime,
      webViewLoadFailTime,
      webViewLoadDuration,
      productsLoadStartTime,
      productsLoadCompleteTime,
      productsLoadFailTime,
      productsLoadDuration,
      paywalljsVersion,
      isFreeTrialAvailable,
      featureGatingBehavior,
      closeReason,
      localNotifications,
      computedPropertyRequests,
      surveys,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PPaywallInfoPigeon) {
      return false
    }
    if (this === other) {
      return true
    }
    return identifier == other.identifier
    && name == other.name
    && experimentBridgeId == other.experimentBridgeId
    && deepEqualsHost(productIds, other.productIds)
    && deepEqualsHost(products, other.products)
    && url == other.url
    && presentedByEventWithName == other.presentedByEventWithName
    && presentedByEventWithId == other.presentedByEventWithId
    && presentedByEventAt == other.presentedByEventAt
    && presentedBy == other.presentedBy
    && presentationSourceType == other.presentationSourceType
    && responseLoadStartTime == other.responseLoadStartTime
    && responseLoadCompleteTime == other.responseLoadCompleteTime
    && responseLoadFailTime == other.responseLoadFailTime
    && responseLoadDuration == other.responseLoadDuration
    && webViewLoadStartTime == other.webViewLoadStartTime
    && webViewLoadCompleteTime == other.webViewLoadCompleteTime
    && webViewLoadFailTime == other.webViewLoadFailTime
    && webViewLoadDuration == other.webViewLoadDuration
    && productsLoadStartTime == other.productsLoadStartTime
    && productsLoadCompleteTime == other.productsLoadCompleteTime
    && productsLoadFailTime == other.productsLoadFailTime
    && productsLoadDuration == other.productsLoadDuration
    && paywalljsVersion == other.paywalljsVersion
    && isFreeTrialAvailable == other.isFreeTrialAvailable
    && deepEqualsHost(featureGatingBehavior, other.featureGatingBehavior)
    && deepEqualsHost(closeReason, other.closeReason)
    && deepEqualsHost(localNotifications, other.localNotifications)
    && deepEqualsHost(computedPropertyRequests, other.computedPropertyRequests)
    && deepEqualsHost(surveys, other.surveys)
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PSuperwallEventInfoPigeon (
  val eventType: PEventType,
  val params: Map<String, Any>? = null,
  val paywallInfoBridgeId: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PSuperwallEventInfoPigeon {
      val eventType = pigeonVar_list[0] as PEventType
      val params = pigeonVar_list[1] as Map<String, Any>?
      val paywallInfoBridgeId = pigeonVar_list[2] as String?
      return PSuperwallEventInfoPigeon(eventType, params, paywallInfoBridgeId)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      eventType,
      params,
      paywallInfoBridgeId,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PSuperwallEventInfoPigeon) {
      return false
    }
    if (this === other) {
      return true
    }
    return eventType == other.eventType
    && deepEqualsHost(params, other.params)
    && paywallInfoBridgeId == other.paywallInfoBridgeId
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PIdentityOptions (
  val restorePaywallAssignments: Boolean? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PIdentityOptions {
      val restorePaywallAssignments = pigeonVar_list[0] as Boolean?
      return PIdentityOptions(restorePaywallAssignments)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      restorePaywallAssignments,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PIdentityOptions) {
      return false
    }
    if (this === other) {
      return true
    }
    return restorePaywallAssignments == other.restorePaywallAssignments
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PExperiment (
  val id: String,
  val groupId: String,
  val variant: PVariant
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PExperiment {
      val id = pigeonVar_list[0] as String
      val groupId = pigeonVar_list[1] as String
      val variant = pigeonVar_list[2] as PVariant
      return PExperiment(id, groupId, variant)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      groupId,
      variant,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PExperiment) {
      return false
    }
    if (this === other) {
      return true
    }
    return id == other.id
    && groupId == other.groupId
    && variant == other.variant
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PVariant (
  val id: String,
  val type: PVariantType,
  val paywallId: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PVariant {
      val id = pigeonVar_list[0] as String
      val type = pigeonVar_list[1] as PVariantType
      val paywallId = pigeonVar_list[2] as String?
      return PVariant(id, type, paywallId)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      type,
      paywallId,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PVariant) {
      return false
    }
    if (this === other) {
      return true
    }
    return id == other.id
    && type == other.type
    && paywallId == other.paywallId
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PConfirmedAssignment (
  val experimentId: String,
  val variant: PVariant
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PConfirmedAssignment {
      val experimentId = pigeonVar_list[0] as String
      val variant = pigeonVar_list[1] as PVariant
      return PConfirmedAssignment(experimentId, variant)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      experimentId,
      variant,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PConfirmedAssignment) {
      return false
    }
    if (this === other) {
      return true
    }
    return experimentId == other.experimentId
    && variant == other.variant
  }

  override fun hashCode(): Int = toList().hashCode()
}
private open class HostPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PNetworkEnvironment.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PLogLevel.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PTransactionBackgroundView.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PLogScope.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PConfigurationStatus.ofRaw(it.toInt())
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PEventType.ofRaw(it.toInt())
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PSubscriptionStatusType.ofRaw(it.toInt())
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PPaywallPresentationRequestStatusType.ofRaw(it.toInt())
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PPaywallPresentationRequestStatusReason.ofRaw(it.toInt())
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PVariantType.ofRaw(it.toInt())
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PSuperwallOptions.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PPaywallInfo.fromList(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PPurchaseResult.fromList(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PRestorationResult.fromList(it)
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PRestoreFailed.fromList(it)
        }
      }
      144.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PLogging.fromList(it)
        }
      }
      145.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PPaywallOptions.fromList(it)
        }
      }
      146.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PPurchaseControllerHost.fromList(it)
        }
      }
      147.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PEntitlement.fromList(it)
        }
      }
      148.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PActive.fromList(it)
        }
      }
      149.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PInactive.fromList(it)
        }
      }
      150.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PUnknown.fromList(it)
        }
      }
      151.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PPaywallInfoPigeon.fromList(it)
        }
      }
      152.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PSuperwallEventInfoPigeon.fromList(it)
        }
      }
      153.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PIdentityOptions.fromList(it)
        }
      }
      154.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PExperiment.fromList(it)
        }
      }
      155.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PVariant.fromList(it)
        }
      }
      156.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PConfirmedAssignment.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is PNetworkEnvironment -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is PLogLevel -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is PTransactionBackgroundView -> {
        stream.write(131)
        writeValue(stream, value.raw)
      }
      is PLogScope -> {
        stream.write(132)
        writeValue(stream, value.raw)
      }
      is PConfigurationStatus -> {
        stream.write(133)
        writeValue(stream, value.raw)
      }
      is PEventType -> {
        stream.write(134)
        writeValue(stream, value.raw)
      }
      is PSubscriptionStatusType -> {
        stream.write(135)
        writeValue(stream, value.raw)
      }
      is PPaywallPresentationRequestStatusType -> {
        stream.write(136)
        writeValue(stream, value.raw)
      }
      is PPaywallPresentationRequestStatusReason -> {
        stream.write(137)
        writeValue(stream, value.raw)
      }
      is PVariantType -> {
        stream.write(138)
        writeValue(stream, value.raw)
      }
      is PSuperwallOptions -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is PPaywallInfo -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is PPurchaseResult -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is PRestorationResult -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is PRestoreFailed -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      is PLogging -> {
        stream.write(144)
        writeValue(stream, value.toList())
      }
      is PPaywallOptions -> {
        stream.write(145)
        writeValue(stream, value.toList())
      }
      is PPurchaseControllerHost -> {
        stream.write(146)
        writeValue(stream, value.toList())
      }
      is PEntitlement -> {
        stream.write(147)
        writeValue(stream, value.toList())
      }
      is PActive -> {
        stream.write(148)
        writeValue(stream, value.toList())
      }
      is PInactive -> {
        stream.write(149)
        writeValue(stream, value.toList())
      }
      is PUnknown -> {
        stream.write(150)
        writeValue(stream, value.toList())
      }
      is PPaywallInfoPigeon -> {
        stream.write(151)
        writeValue(stream, value.toList())
      }
      is PSuperwallEventInfoPigeon -> {
        stream.write(152)
        writeValue(stream, value.toList())
      }
      is PIdentityOptions -> {
        stream.write(153)
        writeValue(stream, value.toList())
      }
      is PExperiment -> {
        stream.write(154)
        writeValue(stream, value.toList())
      }
      is PVariant -> {
        stream.write(155)
        writeValue(stream, value.toList())
      }
      is PConfirmedAssignment -> {
        stream.write(156)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface PSuperwallHostApi {
  fun configure(apiKey: String, purchaseController: PPurchaseControllerHost?, options: PSuperwallOptions?, callback: (Result<Unit>) -> Unit)
  fun reset()
  fun setDelegate(delegateProxyBridgeId: String)
  fun confirmAllAssignments(callback: (Result<List<PConfirmedAssignment>>) -> Unit)
  fun getLogLevel(): String
  fun setLogLevel(logLevel: String)
  fun getUserAttributes(): Map<String, Any>
  fun setUserAttributes(userAttributes: Map<String, Any>)
  fun getLocaleIdentifier(): String?
  fun setLocaleIdentifier(localeIdentifier: String?)
  fun getUserId(): String
  fun getIsLoggedIn(): Boolean
  fun getIsInitialized(): Boolean
  fun identify(userId: String, identityOptions: PIdentityOptions?)
  fun getEntitlements(): List<PEntitlement>
  fun getSubscriptionStatus(): PSubscriptionStatus
  fun setSubscriptionStatus(subscriptionStatus: PSubscriptionStatus)
  fun getConfigurationStatus(): PConfigurationStatus
  fun getIsConfigured(): Boolean
  fun getIsPaywallPresented(): Boolean
  fun preloadAllPaywalls()
  fun preloadPaywallsForPlacements(placementNames: List<String>)
  fun handleDeepLink(url: String): Boolean
  fun togglePaywallSpinner(isHidden: Boolean)
  fun getLatestPaywallInfo(): PPaywallInfo?
  fun dismiss()
  fun registerPlacement(placement: String, params: Map<String, Any>?)

  companion object {
    /** The codec used by PSuperwallHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      HostPigeonCodec()
    }
    /** Sets up an instance of `PSuperwallHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: PSuperwallHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.configure$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val apiKeyArg = args[0] as String
            val purchaseControllerArg = args[1] as PPurchaseControllerHost?
            val optionsArg = args[2] as PSuperwallOptions?
            api.configure(apiKeyArg, purchaseControllerArg, optionsArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.reset$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.reset()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.setDelegate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val delegateProxyBridgeIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.setDelegate(delegateProxyBridgeIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.confirmAllAssignments$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.confirmAllAssignments{ result: Result<List<PConfirmedAssignment>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getLogLevel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getLogLevel())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.setLogLevel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val logLevelArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.setLogLevel(logLevelArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getUserAttributes$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getUserAttributes())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.setUserAttributes$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val userAttributesArg = args[0] as Map<String, Any>
            val wrapped: List<Any?> = try {
              api.setUserAttributes(userAttributesArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getLocaleIdentifier$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getLocaleIdentifier())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.setLocaleIdentifier$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val localeIdentifierArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.setLocaleIdentifier(localeIdentifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getUserId$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getUserId())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getIsLoggedIn$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getIsLoggedIn())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getIsInitialized$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getIsInitialized())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.identify$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val userIdArg = args[0] as String
            val identityOptionsArg = args[1] as PIdentityOptions?
            val wrapped: List<Any?> = try {
              api.identify(userIdArg, identityOptionsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getEntitlements$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getEntitlements())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getSubscriptionStatus$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getSubscriptionStatus())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.setSubscriptionStatus$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val subscriptionStatusArg = args[0] as PSubscriptionStatus
            val wrapped: List<Any?> = try {
              api.setSubscriptionStatus(subscriptionStatusArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getConfigurationStatus$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getConfigurationStatus())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getIsConfigured$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getIsConfigured())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getIsPaywallPresented$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getIsPaywallPresented())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.preloadAllPaywalls$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.preloadAllPaywalls()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.preloadPaywallsForPlacements$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val placementNamesArg = args[0] as List<String>
            val wrapped: List<Any?> = try {
              api.preloadPaywallsForPlacements(placementNamesArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.handleDeepLink$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.handleDeepLink(urlArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.togglePaywallSpinner$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val isHiddenArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.togglePaywallSpinner(isHiddenArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.getLatestPaywallInfo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getLatestPaywallInfo())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.dismiss$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.dismiss()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallHostApi.registerPlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val placementArg = args[0] as String
            val paramsArg = args[1] as Map<String, Any>?
            val wrapped: List<Any?> = try {
              api.registerPlacement(placementArg, paramsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface PSuperwallDelegateApi {
  fun subscriptionStatusDidChange(subscriptionStatusBridgeId: String)
  fun handleSuperwallEvent(eventInfo: PSuperwallEventInfoPigeon)
  fun handleCustomPaywallAction(name: String)
  fun willDismissPaywall(paywallInfo: PPaywallInfo)
  fun willPresentPaywall(paywallInfo: PPaywallInfo)
  fun didDismissPaywall(paywallInfo: PPaywallInfo)
  fun didPresentPaywall(paywallInfo: PPaywallInfo)
  fun paywallWillOpenURL(url: String)
  fun paywallWillOpenDeepLink(url: String)
  fun handleLog(level: String, scope: String, message: String?, info: Map<String, Any>?, error: String?)

  companion object {
    /** The codec used by PSuperwallDelegateApi. */
    val codec: MessageCodec<Any?> by lazy {
      HostPigeonCodec()
    }
    /** Sets up an instance of `PSuperwallDelegateApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: PSuperwallDelegateApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallDelegateApi.subscriptionStatusDidChange$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val subscriptionStatusBridgeIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.subscriptionStatusDidChange(subscriptionStatusBridgeIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallDelegateApi.handleSuperwallEvent$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val eventInfoArg = args[0] as PSuperwallEventInfoPigeon
            val wrapped: List<Any?> = try {
              api.handleSuperwallEvent(eventInfoArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallDelegateApi.handleCustomPaywallAction$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val nameArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.handleCustomPaywallAction(nameArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallDelegateApi.willDismissPaywall$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val paywallInfoArg = args[0] as PPaywallInfo
            val wrapped: List<Any?> = try {
              api.willDismissPaywall(paywallInfoArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallDelegateApi.willPresentPaywall$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val paywallInfoArg = args[0] as PPaywallInfo
            val wrapped: List<Any?> = try {
              api.willPresentPaywall(paywallInfoArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallDelegateApi.didDismissPaywall$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val paywallInfoArg = args[0] as PPaywallInfo
            val wrapped: List<Any?> = try {
              api.didDismissPaywall(paywallInfoArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallDelegateApi.didPresentPaywall$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val paywallInfoArg = args[0] as PPaywallInfo
            val wrapped: List<Any?> = try {
              api.didPresentPaywall(paywallInfoArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallDelegateApi.paywallWillOpenURL$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.paywallWillOpenURL(urlArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallDelegateApi.paywallWillOpenDeepLink$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.paywallWillOpenDeepLink(urlArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.superwallkit_flutter.PSuperwallDelegateApi.handleLog$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val levelArg = args[0] as String
            val scopeArg = args[1] as String
            val messageArg = args[2] as String?
            val infoArg = args[3] as Map<String, Any>?
            val errorArg = args[4] as String?
            val wrapped: List<Any?> = try {
              api.handleLog(levelArg, scopeArg, messageArg, infoArg, errorArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class PPurchaseControllerGenerated(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by PPurchaseControllerGenerated. */
    val codec: MessageCodec<Any?> by lazy {
      HostPigeonCodec()
    }
  }
  fun purchaseFromAppStore(productIdArg: String, callback: (Result<PPurchaseResult>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.superwallkit_flutter.PPurchaseControllerGenerated.purchaseFromAppStore$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(productIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else if (it[0] == null) {
          callback(Result.failure(FlutterError("null-error", "Flutter api returned null value for non-null return value.", "")))
        } else {
          val output = it[0] as PPurchaseResult
          callback(Result.success(output))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun purchaseFromGooglePlay(productIdArg: String, basePlanIdArg: String?, offerIdArg: String?, callback: (Result<PPurchaseResult>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.superwallkit_flutter.PPurchaseControllerGenerated.purchaseFromGooglePlay$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(productIdArg, basePlanIdArg, offerIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else if (it[0] == null) {
          callback(Result.failure(FlutterError("null-error", "Flutter api returned null value for non-null return value.", "")))
        } else {
          val output = it[0] as PPurchaseResult
          callback(Result.success(output))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun restorePurchases(callback: (Result<PRestorationResult>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.superwallkit_flutter.PPurchaseControllerGenerated.restorePurchases$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else if (it[0] == null) {
          callback(Result.failure(FlutterError("null-error", "Flutter api returned null value for non-null return value.", "")))
        } else {
          val output = it[0] as PRestorationResult
          callback(Result.success(output))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
